# Checking the satyr. -*- Autotest -*-

AT_BANNER([JavaScript stacktrace])

AT_TESTFUN([sr_js_stacktrace_parse_v8],
[[
#include "js/stacktrace.h"
#include "js/frame.h"
#include "utils.h"
#include "strbuf.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void
print_frame(FILE *out, struct sr_js_frame *frame)
{
    struct sr_strbuf *buf = sr_strbuf_new();
    sr_js_frame_append_to_str(frame, buf);
    fprintf(out, "%s", buf->buf);
    sr_strbuf_free(buf);
}

void
check(char *filename, char *exc_name, unsigned frame_count,
      struct sr_js_frame *top_frame,
      struct sr_js_frame *second_frame,
      struct sr_js_frame *bottom_frame)
{
    char *error_message = NULL;
    char *file_contents = sr_file_to_string(filename, &error_message);
    const char *input = file_contents;
    struct sr_location location;
    sr_location_init(&location);

    struct sr_js_stacktrace *stacktrace = sr_js_stacktrace_parse_v8(&input, &location);
    assert(stacktrace);
    assert(*input == '\0');
    if (0 != sr_strcmp0(stacktrace->exception_name, exc_name)) {
        fprintf(stderr, "exception_name -> '%s' != '%s'\n", stacktrace->exception_name, exc_name);
        assert(!"Parsed exception name");
    }

    struct sr_js_frame *frame = stacktrace->frames;
    int i = 0;
    while (frame)
    {
        if (i==0 && top_frame) {
            if (sr_js_frame_cmp(frame, top_frame) != 0) {
                print_frame(stderr, frame);
                fprintf(stderr, "\n  !=\n");
                print_frame(stderr, top_frame);
                fprintf(stderr, "\n");
                assert(!"Invalid top frame");
            }
        }
        else if (i == 1 && second_frame) {
            if (sr_js_frame_cmp(frame, second_frame) != 0) {
                print_frame(stderr, frame);
                fprintf(stderr, "\n  !=\n");
                print_frame(stderr, second_frame);
                fprintf(stderr, "\n");
                assert(!"Invalid second frame");
            }
        }

        frame = frame->next;
        i++;
    }

    assert(i == frame_count);
    if (frame && bottom_frame)
    {
        if (sr_js_frame_cmp(frame, bottom_frame) != 0) {
            print_frame(stderr, frame);
            fprintf(stderr, "\n  !=\n");
            print_frame(stderr, bottom_frame);
            fprintf(stderr, "\n");
            assert(!"Invalid bottom frame");
        }
    }

    sr_js_stacktrace_free(stacktrace);
    free(file_contents);
}

int
main(void)
{
    {
        struct sr_js_frame top = {
            .type = SR_REPORT_JAVASCRIPT,
            .file_name = "/tmp/index.js",
            .file_line = 2,
            .line_column = 1,
            .function_name = "Object.<anonymous>",
        };
        struct sr_js_frame second = {
            .type = SR_REPORT_JAVASCRIPT,
            .file_name = "module.js",
            .file_line = 556,
            .line_column = 32,
            .function_name = "Module._compile",
        };
        struct sr_js_frame bottom = {
            .type = SR_REPORT_JAVASCRIPT,
            .file_name = "bootstrap_node.js",
            .file_line = 509,
            .line_column = 3,
            .function_name = NULL,
        };
        check("../../js_stacktraces/node-01", "ReferenceError", 10, &top, &second, &bottom);
    }

    {
        struct sr_js_frame top = {
            .type = SR_REPORT_JAVASCRIPT,
            .file_name = "/tmp/index.js",
            .file_line = 16,
            .line_column = 35,
            .function_name = "Socket.<anonymous>",
        };
        struct sr_js_frame second = {
            .type = SR_REPORT_JAVASCRIPT,
            .file_name = "events.js",
            .file_line = 286,
            .line_column = 16,
            .function_name = "Socket.g",
        };
        struct sr_js_frame bottom = {
            .type = SR_REPORT_JAVASCRIPT,
            .file_name = "net.js",
            .file_line = 1068,
            .line_column = 10,
            .function_name = "PipeConnectWrap.afterConnect",
        };
        check("../../js_stacktraces/node-02", "TypeError", 5, &top, &second, &bottom);
    }

  return 0;
}
]])

AT_TESTFUN([sr_js_stacktrace_dup],
[[
#include "js/stacktrace.h"
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

void
check(char *filename)
{
  char *error_message = NULL;
  const char *file_contents = sr_file_to_string(filename, &error_message);
  const char *input = file_contents;
  struct sr_location location;
  sr_location_init(&location);

  struct sr_js_stacktrace *stacktrace1 = sr_js_stacktrace_parse(&input, &location);
  struct sr_js_stacktrace *stacktrace2 = sr_js_stacktrace_dup(stacktrace1);

  assert(stacktrace1 != stacktrace2);
  printf("%s == %s\n", stacktrace1->exception_name, stacktrace2->exception_name);
  assert(0 == strcmp(stacktrace1->exception_name, stacktrace2->exception_name));

  struct sr_js_frame *f1 = stacktrace1->frames;
  struct sr_js_frame *f2 = stacktrace2->frames;

  while (f1 && f2)
  {
    assert(0 == sr_js_frame_cmp(f1, f2));
    f1 = f1->next;
    f2 = f2->next;
  }
  assert(f1 == NULL);
  assert(f2 == NULL);

  sr_js_stacktrace_free(stacktrace1);
  sr_js_stacktrace_free(stacktrace2);
  free(file_contents);
}

int
main(void)
{
  check("../../js_stacktraces/node-01");
  check("../../js_stacktraces/node-02");

  return 0;
}
]])

AT_TESTFUN([sr_js_stacktrace_get_reason],
[[
#include "js/stacktrace.h"
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

int
main(void)
{
  char *error_message = NULL;
  const char *file_contents = sr_file_to_string("../../js_stacktraces/node-01", &error_message);
  const char *input = file_contents;
  struct sr_location location;
  sr_location_init(&location);
  struct sr_js_stacktrace *stacktrace1 = sr_js_stacktrace_parse(&input, &location);

  char *reason = sr_js_stacktrace_get_reason(stacktrace1);
  char *expected = "ReferenceError in ";
  assert(0 == strcmp(reason, expected));

  sr_js_stacktrace_free(stacktrace1);
  free(file_contents);

  return 0;
}
]])

AT_TESTFUN([sr_js_stacktrace_to_json],
[[
#include "js/stacktrace.h"
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

void
check(char *filename, char *json_filename)
{
  char *error_message = NULL;
  const char *file_contents = sr_file_to_string(filename, &error_message);
  const char *input = file_contents;
  struct sr_location location;
  sr_location_init(&location);

  struct sr_js_stacktrace *stacktrace1 = sr_js_stacktrace_parse(&input, &location);

  char *expected = sr_file_to_string(json_filename, &error_message);
  char *json = sr_js_stacktrace_to_json(stacktrace1);

  assert(0 == strcmp(json, expected));

  sr_js_stacktrace_free(stacktrace1);
  free(json);
  free(file_contents);
}

int
main(void)
{
  check("../../js_stacktraces/node-01", "../../js_stacktraces/node-01-expected-json");
  check("../../js_stacktraces/node-02", "../../js_stacktraces/node-02-expected-json");

  return 0;
}
]])

AT_TESTFUN([sr_js_stacktrace_from_json],
[[
#include "stacktrace.h"
#include "js/stacktrace.h"
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void
check(char *filename)
{
  char *error_message = NULL;
  char *file_contents = sr_file_to_string(filename, &error_message);
  char *input = file_contents;
  struct sr_location location;
  sr_location_init(&location);

  struct sr_js_stacktrace *stacktrace1 = sr_js_stacktrace_parse(&input, &location);

  char *json = sr_js_stacktrace_to_json(stacktrace1);
  struct sr_js_stacktrace *stacktrace2 = sr_stacktrace_from_json_text(SR_REPORT_JAVASCRIPT, json, &error_message);

  assert(0 == strcmp(stacktrace1->exception_name, stacktrace2->exception_name));

  struct sr_js_frame *f1 = stacktrace1->frames;
  struct sr_js_frame *f2 = stacktrace2->frames;

  while (f1 && f2)
  {
    assert(0 == sr_js_frame_cmp(f1, f2));
    f1 = f1->next;
    f2 = f2->next;
  }
  assert(f1 == NULL);
  assert(f2 == NULL);

  sr_js_stacktrace_free(stacktrace1);
  sr_js_stacktrace_free(stacktrace2);
  free(json);
  free(file_contents);
}

int
main(void)
{
  check("../../js_stacktraces/node-01");

  return 0;
}
]])
