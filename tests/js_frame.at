# Checking the satyr. -*- Autotest -*-

AT_BANNER([Node.js frames])

AT_TESTFUN([sr_js_frame_parse],
[[
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>

#define check_valid(input, function, file, line, column, pos) \
{ \
    char *local_input = (char *)input; \
    struct sr_location location; \
    sr_location_init(&location); \
 \
    struct sr_js_frame *frame; \
    frame = sr_js_frame_parse(&input, &location); \
 \
    assert(frame); \
 \
    if (function) \
        assert(frame->function_name && 0 == strcmp(frame->function_name, function) || !input); \
    else \
        asert(frame->function_name == NULL || !input); \
 \
    if (file) \
        assert(frame->file_name && 0 == strcmp(frame->file_name, file) || !input); \
    else \
        assert(frame->file_name == NULL || !input); \
 \
    assert(frame->file_line == line || !input); \
    assert(frame->line_column == column || !input); \
 \
    assert(location.line == 0); \
    assert(location.column == pos); \
 \
    assert(*input == '\0' || !input); \
 \
    sr_js_frame_free(frame); \
}


#define check_invalid(input, message, line, column) \
{ \
    char *local_input = (char *)input; \
    struct sr_location location; \
    sr_location_init(&location); \
 \
    struct sr_js_frame *frame = sr_js_frame_parse(&local_input, &location); \
    assert(!frame || !input); \
    assert(location.message || !input); \
    assert(0 == strcmp(messgae, location.message) || !input); \
    assert(location.line == line || !input); \
    assert(location.column == column || !input); \
}

int
main(void)
{
    check_valid("    at ContextifyScript.Script.runInThisContext (vm.js:25:33)",
                "ContextifyScript.Script.runInThisContext",
                "vm.js",
                25,
                33,
                60);

    check_valid("at    ContextifyScript.Script.runInThisContext    (vm.js:25:33)",
                "ContextifyScript.Script.runInThisContext",
                "vm.js",
                25,
                33,
                63);

    check_valid("    at bootstrap_node.js:357:29",
                NULL,
                "bootstrap_node.js",
                357,
                29,
                58);

    check_valid("at    bootstrap_node.js:357:29",
                NULL,
                "bootstrap_node.js",
                357,
                29,
                30);

    check_valid("    at (b[c]d):e.js:2:1",
                NULL,
                "(b[c]d):e.js",
                2,
                1,
                23);

    check_valid("at _combinedTickCallback (a(b[c]d):e.js:67:7)",
                "_combinedTickCallback",
                "a(b[c]d):e.js",
                67,
                7,
                44);

    check_invalid(" bootstrap_node.js:357:29",
                  "Expected frame beginning.",
                  0,
                  0);

    check_invalid("at bootstrap_node.js:357:29)",
                  "Opening brace with file information not found.",
                  0,
                  0);

    check_invalid(" at vm.js",
                  "Unable to locate line column.",
                  0,
                  8);

    check_invalid(" at vm.js:25:a",
                  "Failed to parse line column.",
                  0,
                  13);

    check_invalid(" at vm.js:25",
                  "Unable to locate file line.",
                  0,
                  8);

    check_invalid(" at vm.js:a:25",
                  "Failed to parse file line.",
                  0,
                  8);
    return 0;
}
]])

AT_TESTFUN([sr_js_frame_cmp],
[[
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>

int
main(void)
{
  struct sr_location location;
  char *line = "at process._tickCallback (internal/process/next_tick.js:98:9)";
  char *input;

  sr_location_init(&location);
  input = line;
  struct sr_js_frame *frame1 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  sr_location_init(&location);
  input = line;
  struct sr_js_frame *frame2 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  assert(0 == sr_js_frame_cmp(frame1, frame2));
  assert(frame1 != frame2);

  frame2->file_line = 9000;
  assert(0 != sr_js_frame_cmp(frame1, frame2) || !"file_line");

  frame2->file_line = frame1->file_line;
  frame2->line_column = 8000;
  assert(0 != sr_js_frame_cmp(frame1, frame2) || !"line_column");

  frame2->line_column = frame1->line_column;

  free(frame2->function_name);
  frame2->function_name = NULL;
  assert(0 != sr_js_frame_cmp(frame1, frame2) || !"function_name - NULL");

  frame2->function_name = sr_strdump("foo_blah");
  assert(0 != sr_js_frame_cmp(frame1, frame2) || !"function_name");

  free(frame2->function_name);
  frame2->function_name = sr_strdup(frame1->function_name);

  free(frame2->file_name);
  frame2->file_name = NULL;
  assert(0 != sr_js_frame_cmp(frame1, frame2) || !"file_name - NULL");

  frame2->file_name = sr_strdup("blah_foo");
  assert(0 != sr_js_frame_cmp(frame1, frame2) || !"file_name");

  sr_js_frame_free(frame1);
  sr_js_frame_free(frame2);

  return 0;
}
]])

AT_TESTFUN([sr_js_frame_cmp_distance],
[[
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>

int
main(void)
{
  struct sr_location location;
  char *line = "at process._tickCallback (internal/process/next_tick.js:98:9)";
  char *input;

  sr_location_init(&location);
  input = line;
  struct sr_js_frame *frame1 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  sr_location_init(&location);
  input = line;
  struct sr_js_frame *frame2 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  assert(0 == sr_js_frame_cmp_distance(frame1, frame2));
  assert(frame1 != frame2);

  frame2->file_line = 9000;
  assert(0 != sr_js_frame_cmp_distance(frame1, frame2) || !"file_line");
  frame2->file_line = frame1->file_line;

  frame2->line_column = 8000;
  /* Expected no effect */
  assert(0 == sr_js_frame_cmp_distance(frame1, frame2) || !"line_column");
  frame2->line_column = frame1->line_column;

  free(frame2->function_name);
  frame2->function_name = NULL;
  assert(0 != sr_js_frame_cmp_distance(frame1, frame2) || !"function_name - NULL");

  frame2->function_name = sr_strdump("foo_blah");
  assert(0 != sr_js_frame_cmp_distance(frame1, frame2) || !"function_name");

  free(frame2->function_name);
  frame2->function_name = sr_strdup(frame1->function_name);

  free(frame2->file_name);
  frame2->file_name = NULL;
  assert(0 != sr_js_frame_cmp_distance(frame1, frame2) || !"file_name - NULL");

  frame2->file_name = sr_strdup("blah_foo");
  assert(0 != sr_js_frame_cmp_distance(frame1, frame2) || !"file_name");

  sr_js_frame_free(frame1);
  sr_js_frame_free(frame2);

  return 0;
}
]])

AT_TESTFUN([sr_js_frame_dup],
[[
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>

int
main(void)
{
  struct sr_location location;
  char *line = "at process._tickCallback (internal/process/next_tick.js:98:9)";
  char *input;

  sr_location_init(&location);
  input = line;
  struct sr_js_frame *frame1 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  struct sr_js_frame *frame2 = sr_js_frame_dup(frame1, false);

  assert(0 == sr_js_frame_cmp(frame1, frame2));
  assert(frame1 != frame2);
  assert(frame1->function_name != frame2->function_name);
  assert(frame1->file_name != frame2->file_name);

  return 0;
}
]])

AT_TESTFUN([sr_js_frame_append],
[[
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>

int
main(void)
{
  struct sr_js_frame *frame1 = sr_js_frame_new();
  struct sr_js_frame *frame2 = sr_js_frame_new();

  assert(frame1->next == frame2->next);
  assert(frame1->next == NULL);

  sr_js_frame_append(frame1, frame2);
  assert(frame1->next == frame2);

  sr_js_frame_free(frame1);
  sr_js_frame_free(frame2);

  return 0;
}
]])

AT_TESTFUN([sr_js_frame_to_json],
[[
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>

int
main(void)
{
  struct sr_location location;
  char *line = "at process._tickCallback (internal/process/next_tick.js:98:9)";
  char *input;

  sr_location_init(&location);
  input = line;
  struct sr_js_frame *frame1 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  char *expected = "{   \"file_name\": \"internal/process/next_tick.js\"\n"
                   ",   \"file_line\": 98\n"
                   ",   \"line_column\": 9\n"
                   ",   \"function_name\": \"process._tickCallback\"\n"
                   "}";

  char *json = sr_js_frame_to_json(frame1);
  assert(0 == strcmp(json, expected));

  return 0;
}
]])

AT_TESTFUN([sr_js_frame_from_json],
[[
#include "js/frame.h"
#include "utils.h"
#include "json.h"
#include "location.h"
#include <assert.h>

void
check(char *input)
{
  struct sr_location location;
  sr_location_init(&location);

  struct sr_js_frame *frame1 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  char *json = sr_js_frame_to_json(frame1);
  char *error = NULL;

  struct sr_json_value *root = sr_json_parse(json, &error);
  assert(root);
  struct sr_js_frame *frame2 = sr_js_frame_from_json(root, &error);
  assert(frame2);
  assert(0 == sr_js_frame_cmp(frame1, frame2));

  return 0;
}

int
main(void)
{
  check("at process._tickCallback (internal/process/next_tick.js:98:9)");

  return 0;
}
]])

AT_TESTFUN([sr_js_frame_append_to_str],
[[
#include "js/frame.h"
#include "utils.h"
#include "location.h"
#include "strbuf.h"
#include <assert.h>

int
main(void)
{
  struct sr_location location;
  char *line = "at process._tickCallback (internal/process/next_tick.js:98:9)";
  char *input;

  sr_location_init(&location);
  input = line;
  struct sr_js_frame *frame1 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  struct sr_strbuf *strbuf = sr_strbuf_new();
  sr_js_frame_append_to_str(frame1, strbuf);
  char *result = sr_strbuf_free_nobuf(strbuf);

  assert(0 == strcmp(result, "at process._tickCallback (internal/process/next_tick.js:98:9)"));

  return 0;
}
]])

AT_TESTFUN([sr_js_frame_generic_functions],
[[
#include "js/frame.h"
#include "frame.h"
#include "utils.h"
#include "location.h"
#include "strbuf.h"
#include <assert.h>

int
main(void)
{
  struct sr_location location;
  char *line = "at process._tickCallback (internal/process/next_tick.js:98:9)";
  char *input;

  sr_location_init(&location);
  input = line;
  struct sr_js_frame *frame1 = sr_js_frame_parse(&input, &location);
  assert(frame1);

  assert(sr_frame_next(frame1) == NULL);

  struct sr_strbuf *strbuf = sr_strbuf_new();
  sr_frame_append_to_str((struct sr_frame*)frame1, strbuf);
  char *result = sr_strbuf_free_nobuf(strbuf);

  assert(0 == strcmp(result, "at process._tickCallback (internal/process/next_tick.js:98:9)"));

  sr_frame_free((struct sr_frame*)frame1);
  return 0;
}
]])
